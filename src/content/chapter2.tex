\chapter{Versionsverwaltung}\label{cha:Versionsverwaltung}
\section{Definition}\label{sec:Definition}
Versionskontrollsysteme sind auch bekannt als Versionsverwaltungssysteme (engl.
\acrlong{vcs}), Quellcode Verwaltung(engl. Source Control) oder
Revisionskontollsysteme(engl. Revision Control System). Mit diesen Begriffen
sind Systeme gemeint die es Entwicklern, Teams oder Organisationen erlauben
eine vollständige Historie mit allen Änderungen an dem Quellcode ihrer
gemeinsam entwickelten Software zu verwalten. Ausschlaggebend ist hierbei das
für alle Nutzer transparent wird wer, wann und vor allem warum welche
Änderungen durchgeführt hat. Eine weiterer wichtige Eigentschaft ist das es
verschiedenen Teams eine Zusammenarbeit an ggf\. verschiedenen Teilen der
Software ermöglicht ohne sich gegenseitig zu
behindern\footnote{\label{dev:1}Das hängt natürlich nicht nur von dem
Versionskontollsystem ab sondern auch von dem Design der entwickelten Software.
Diese wird i.d.R. eher modular aufgebaut so das die Möglichkeit einer paralelle
Entwicklung unterstützt wird.}.\cite[s.~381]{cd}\\

Es wird in nachvolgenden Abschnitten nicht im Detail auf alle existierende
Versionskontollsysteme eingegangen. Viel mehr wird ein kleiner Ausschnitt
vorgestellt von wenigen Systemen der dazu dienen einen Überblick über die
grundlegende Entwicklung von \glspl{vcs} zu vermitteln.

\section{Geschichtliche Entwicklung}\label{sec:GeschichtlicheEntwicklung}
Das erste Versionskontrollsystem namens SCCS enstand 1972 und wurde von Marc J.
Rockkind bei Bell Labs
geschrieben\footnote{\url{http://www.belllabs.com/}}\cite[s.~382]{cd}. Ab diesem
Zeitpunkt enstand eine Vielzahl von verschiedenen Versionskontollsystemen.  Als
Alternative zu dem properitären \acrshort{sccs} folgte Anfang 1980 das von
Walter F. Tichy an Purdue University entwickelte erste \acrlong{OpenSource}
Versionskontrollsystem \acrfull{rcs}\cite{paper:rcs,link:rcs}. Ross Ridge
veröffentlichte 1993 mit einer Beta Version von \acrshort{mysc} einen freien
Ersatz für \acrshort{sccs}. In späteren Versionen wurde \acrshort{mysc} in
\acrfull{cssc} umbenannt\cite{link:cssc,link:mysc}. Alle drei Systeme finden in
der Praxis nur noch wenig Anwendung und daher wird an dieser Stelle nicht auf
weiter auf Details eingegangen.

\subsection{CVS}\label{sec:cvs}
Das 1986 durch Dick Grune veröffentlichte \acrfull{cvs} war das erste freie
Versionskontrollsystem mit einem zentralen \gls{repository}. Das wurde ereicht
in dem \acrshort{rcs}, mit Hilfe eines \gls{wrapper}, um eine
Client-/Serverkomponente erweitert wurde. Das ermöglichte erstmals das mehrere
Entwickler gleichzeitig an einem \gls{repository} und konkurrierend an den
selben Dateien arbeiten konnten. Neben dem innovativen Ansatz gabe es hier aber
noch einige technische Einschränkungen die ein kollaboratives Arbeiten
erschwerten. So war z.B. die Nutzung des verbrauchten Speicherplatzes nicht
optimal. Das erzeugen von Abzweigungen (Branches) wurde durch einfaches
Kopieren erreicht. Das war deshalb nicht nur Zeitaufwändig sondern verbrauchte
auch entsprechenden Speicherplatz. Ein späteres Zusammenführen (mergen) dieser
Zweige führte daher zu Dateikonflikten und verursachte hierduch erheblichen
Aufwand. Auch gab es keine Funktonalität Binärdateien zu verwalten so das hier
der Speicherplatz auch eher ineffizient genutzt wurde. Das erstellen von Tags
war mit wachsendem Inhalt des \glspl{repository} ebenfalls Zeitaufwändig da
alle enthaltenen Dateien bearbeitet werden mussten. Eine der, aus heutiger
Sicht, größte Einschränkung war aber sicher die Tatsache das Commits in das
\gls{repository} nicht Atomar waren. Wurde die Übertragung der Dateien in das
zentrale \gls{repository} unterbrochen so wurde dieses in einem inkonsistenten
und nicht nutzbaren Zustand hinterlassen und musste administrativ repariert
werden. \cite[s.~382-383]{cd}

\subsection{SVN}\label{sec:svn}
Das Ziel des als quasi Nachfolger zu \acrshort{cvs} entwickelten
Versionsverwaltungssystem \acrfull{svn} war es die technischen Einschränkungen
von \acrshort{cvs} zu beheben. Es wurde darauf geachtet das es als Ersatz
fungieren kann und einen Umstieg möglichst einfach zu machen. Ebenso
funktioniert das Benutzerinterface ähnich zu \acrshort{cvs} so das Entwickler
sich nach einem Umstieg leichter zurecht finden. Als zentrale Neuerung wird
hier, im Gegensatz zu \acrshort{rcs} und \acrshort{sccs} sind nicht mehr die
Dateien zentraler Bestandteil der Versionierung sondern die sogenannte SVN
Revision. Jede Revision enthält einen eindeutigen Stand aller Dateien im
\gls{repository} zu einem bestimmten Zeitpunkt und ist global gültig und
eindeutig. Das ermöglicht konkrete Vergleiche welche Veränderungen zwischen
zwei Revisionen durchgeführt wurden. Alle Änderungen, wie z.b. das Kopieren,
Hinzufügen oder Entfernen von Dateien werden Atomar durchgeführt. Im Gegensatz
zu \acrshort{cvs} geht die Historie einer Datei nicht verloren wenn Sie kopiert
wird. Das erstellen von Tags oder Branches wurde ebenfalls verbessert. Hierzu wurde eine Konvention eingeführt die drei verschiedene Verzeichnisse innerhalb eines \glspl{repository} vorgibt.
\begin{itemize}
\item \textbf{trunk}: Enthält die Revision an der gemeinsam gearbeitet wird
       und von der Branches und Tags erzeugt werden.
\item \textbf{tags}: Verzeichnis in dem unterschiedliche Verzeichnisse als
       Tags erzeugt werden die von einer bestimmten Revision erzeugt werden.
\item \textbf{branches}: Verzeichnis in dem unterschiedliche Verzeichnisse als
      Abzweigungen angelegt werden. Hierauf kann unabhängig von \textit{trunk}
      gearbeitet werden.
\end{itemize}
Die o.a. Verzeichnsse bzw. Tags und Branches sind lediglich Zeiger auf eine
bestimmte Revision und die Trennung dazwischen ist nur eine Konvention. So
werden Tags und Branches erzeugt in dem ein Verzeichnis angelegt wird und der
Inhalt von \textit{trunk} kopiert wird. Das führt auch zu einem der Probleme
bei dem Arbeiten mit \acrlong{svn}. Tags sind nicht eindeutig und veränderbar.
So macht SVN technisch keinen Unterschied zwischen \textit{trunk},
\textit{tags}, \textit{branches} oder einem beliebigen anderen Verzeichnis.
Alle können in der gleichen Art und Weise bearbeitet werden. Eine weiterer
Vorteil ist, das mit \acrlong{svn} auch gearbeitet werden kann wenn das
Netzwerk nicht zur Verfügung. Alle Änderungen an Dateien werden i.d.R.  erstmal
auf einer lokalen Kopie durchgeführt und mit einem seperaten Kommando an das
zentrale Repository gesendet. Als weitere Funktionalität seien noch sogenannte
Externals genannt die es erstmals ermöglichen Inhalte von anderen Repositorys
einzubinden. Dies kann nützlich sein um Abhängigkeiten zwischen
unterschiedlicher Software oder \glspl{repository} abzubilden oder Binärdateien
auszulagern. \acrlong{svn} war zwar eine erhebliche Neuerung gegenüber
\acrlong{cvs} hatte aber aufgrund der zusätzlichen Client-/Server Komponente
einige neue Probleme. So waren z.B. zwar die Aktionen auf seiten des zentralen
\glspl{repository} atomar aber nicht auf seiten des Clients. So das hier, bei
unvorhergesehenen Fehlern, wieder Inkonsistenzen entstehen konnten.  Des
weiteren verwaltet \acrshort{svn} mit Hilfe eines Verzeichnisses \textit{.svn}
innerhalb eines jeden Verzeichnisses. Innerhalb dieses Ordners werden
Verwaltungsinformationen gespeichert. Das ermöglicht eine unabhängige
Verwaltung aller Verzeichnisse untereinander und führt ggf\. dazu das die
lokale Kopie eine Zusammenstellung von unterschiedlichen Revisionen ist und
keinen eindeutigen Stand representiert. Das sind nur einige der Probleme mit
SVN auf eine weitere Ausführung wird aus Platzgründen verzichtet und kann in
einschlägiger Literatur nachgelesen werden.\cite[s.~383-385]{cd}

\subsection{Git}\label{git}
Git ist ein verteiltes bzw. dezentrales \acrlong{vcs:de}. Es wurde von Linux
Torvalds und Junio Hamano entwickelt und ist für die gängigen Platformen wie
Linux, BSD und Windows u.a. verfügbar. Der Name Git kommt nach einem Zitat von
Linux Torvalds wie folgt zustande\cite{link:gitfaq}:

\begin{center}
\textit{\glqq{}I'm an egotistical bastard, and I name all my projects after
myself. First 'Linux', now 'Git'\grqq{}}\\
\end{center}

Alternativ stellt Linux Torvalds noch
weitere Varianten als Acronym für Git zur Verf\-ügung\cite{link:gitfaq}:

\begin{itemize}
  \item \textit{\glqq{}Random three-letter combination that is pronounceable, and not
  actually used by any common UNIX command. The fact that it is a
  mispronunciation of "get" may or may not be relevant.\grqq{}}
  \item \textit{\glqq{}Stupid. Contemptible and despicable. Simple. Take your pick from the
  dictionary of slang.\grqq{}}
  \item \textit{\glqq{}Global information tracker": you're in a good mood, and it actually
  works for you. Angels sing and light suddenly fills the room.\grqq{}}
  \item \textit{\glqq{}Goddamn idiotic truckload of sh*t": when it breaks\grqq{}}
\end{itemize}

Linux Torvalds nutzte ursprünglich als Versionsverwaltung das kommerzielle System BitKeeper für
die Entwicklung am Linux
Kernel\footnote{\url{https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git}}.
Nach Unstimmigkeiten mit dem Hersteller von BitKeeper entschloss Linux Tovalds
sich dazu ein neues \gls{vcs:de} zu schreiben. Dieses sollte weit mehr als
eine Alternative zu den bisherigen sein\cite[s.~13]{gitosp}. So lautete 2005
eine Aussage von Linus Torvalds zu \acrshort{cvs}\cite[s.~385]{cd}:

\begin{center}
\textit{\glqq{}There is no way to do CVS right\grqq{}}\\
\end{center}

Neben dem beheben der Probleme mit denen die populären Systeme (Abschnitt
\ref{sec:svn} und \ref{sec:cvs}) zu kämpfen hatten sollte der zentrale
Augenmerk auf Geschwindigkeit und Integrität liegen. Schon wenige Wochen nach
dem Start der Arbeit an Git konnten die ersten Versionen bereits Quellkode
verwalten. Die grundlegenden Konzepte sind bis heute gleich geblieben. Die
spätere erfolgreiche Migration und Verwaltung des Linux Kernel
\glspl{repository} mit Git führte zu einem hohen ansehen und einer starken
Verbreitung von Git. Die Anforderungen an ein \gls{vcs:de} um den Linux Kernel
mit über 1000 Entwicklern zu verwalten sind immens. Allein zwischen zwei
Versionen finden sich mehrere hunderttausend Änderungen in über 1000 Dateien
und etliche Merges zwischen verschiedenen Branches (Abschnitt
\ref{cha:kernel}). Git selbst ist heutzutage insbesonderen bei großen Projekten
kaum mehr wegzudenken.\cite[s.~13]{gitosp}

\section{Kollaboration}
Die Möglichkeit Änderungen transparent und nachvollziehbar in einem
\gls{repository} zu speichern und bei Bedarf wieder zurückzunehmen oder Stände
die zu unterschiedlichen Zeitpunkten erzeugt wurden zu vergleichen,
\textit{\glqq{}mergen\grqq{}} und Teile davon wieder herzustellen ermöglicht es
die Zusammenarbeit in Teams oder Organisationen erheblich zu verbessern. Alle
beteiligten werden damit konfrontiert das mehrere Personen und Teams am
gleichen Inhalten zur gleichen Zeit arbeiten müssen. Das verbessert den Umgang
mit Konflikten, seien sie technischer oder organisatorischer Art, die eben
durch eine solche Zusammenarbeit enstehen. Der frühe Einsatz eines
\acrlong{vcs:de} sollte als eine gute Angewohnheit angesehen werden die einen
positiven Einfluss auf die Zusammenarbeit hat. Da nicht alle
Versionskontrollsysteme die gleichen Funktionen unterstützen sollte bei der
Auswahl des einzusetztenden \acrlong{vcs:de} darauf geachtet werden welche
Eigenschaften der Zusammenarbeit gefördert werden sollen. So könnten das nach
Jennifer Davis und Katherine Daniels in \cite[S.~178]{effdo} z.b. folgende sein:

\begin{itemize}
\item erstellen und abzweigen von Repositories,
\item beitragen zu Repositories bwz. das verwalten von Beiträgen,
\item festlegen von Prozessen oder
\item das verwalten von Berechtigungen innerhalb von Repositories.
\end{itemize}

Ebenso hat der Einsatz eines \acrlong{vcs:de} auch einen Einfluss auf Risiken
die beispielsweise bei Änderungen an einer produktiven Softwareplattform (z.B.
eines Internetportals) enstehen. Hierdurch wird \acrlong{vcs:de} es möglich, im
Fehlerfall, eine frühere Version der Software wieder einzusetzten und eben
solche Risiken zu verringern.\cite[S.~178]{effdo}

Auch ist ein \acrlong{vcs:de} nicht nur für Quellcode Dateien geeignet. Die
Aussage von Jez Humble und David Farley in \cite[S.~33]{cd} lautet:

\begin{center}
\glqq{}Keep Absolutely Everything in Verison Control\grqq{}
\end{center}

Jede Datei die benötigt wird um die Software reproduzierbar zu erzeugen und zu
verwalten sollte sich unter Versionskontolle befinden. Das können beliebige
Dateien sein wie z.B.

\begin{itemize}
\item Quellcode,
\item Tests,
\item Skripte zum Kompilieren oder zur Datenbankverwaltung,
\item Bibliotheken oder
\item Konfigurationen.
\end{itemize}

So können neue Mitglieder schnell in Teams integriert werden und anfangen zu
arbeiten. Es ist ebenfalls wichtig das alle benötigten Informationen mit unter
Versionskontolle sind und allen zur Verfügung stehen. Hierzu gehören neben
Dokumentationen auch z.B. Projekt- und Releasepläne der Manager oder Dokumente
über durchgeführte Analysen. Darüber hinaus sollten auch externe Abhängigkeiten
mit verwaltet werden. So könnten hier ebenso

\begin{itemize}
\item DNS Zonendateien,
\item Regeln für eine Firewall oder
\item die Konfiguration für eine Entwicklungsumgebung mit abgelegt werden.
\end{itemize}

Im Kern alles was nötig ist um Umgebungen (insbesondere test und
produktive\footnote{Es gibt hier sicher eine Vielzahl von Szenarien die es
erfordern hierzu in der Lage zu sein. Wenn man nicht gerade wie Anbieter
einschlägiger Suchmaschinen nicht z.B. von einem abbrennen eines Datenzentrums
abhängig ist.}) von Grund auf neu erzeugt werden können. Erst wenn all diese
Informationen und Dateien, die sich über die Zeit verändern, in einem
Versionskontrollsystem verwaltet werden ist es möglich das Projekt oder die
Software von/zu einem beliebigen Zeitpunkt in der Historie wieder herzustellen.
\cite[S.~33]{cd}

\section{Allgemeine Grundlagen}\label{sec:Grundlagen}
Um
\subsection{Commits}
Als Commit wird eine Sammlung von aktionen, die ist eine Sammlung von
\subsection{Tags}\label{sec:Tags}
\subsection{Branches}\label{sec:Branches}
\subsection{Merge}
\subsection{Repository}

\subsection{Integrität}

\section{Arten von Versionsverwaltungssystemen}
\subsection{Lokal}
Beide Systeme arbeiteten auf dem lokalen
Dateisystem.,
\subsection{Zentral}
\subsection{Verteilte}
\subsection{Streaming}

\label{sec:why}

